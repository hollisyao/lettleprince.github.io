---
layout: post
title: "基于MVVM的RAC应用"
description: ""
category: articles
tags: [RAC]
comments: true
---

## MVVM架构思想

`MVC`是`iOS`开发中使用最普遍的架构模式，同时也是苹果官方推荐的架构模式。`MVC`代表的是`model–view–controller`，它们之间的关系如下：

![mvc](http://7xr0hq.com1.z0.glb.clouddn.com/mvvm1.png)

`Model`呈现数据，`View`呈现用户界面，而`ViewController`调节它两者之间的交互。看起来很完美。可是稍微考虑一下，虽然`View`和`ViewController`是技术上不同的组件，但它们几乎总是成对的出现。

所以如果把`View`和`ViewController`合并起来成为`View
`层，当然逻辑关系会变得很简单：

![mv](http://7xr0hq.com1.z0.glb.clouddn.com/intermediate.png)

可是，`View`的逻辑太复杂了，我们可以把涉及到逻辑的代码抽离出来放到“逻辑层”中（通常称之为`ViewModel`），于是，逻辑图变成了这样：

![mvvm](http://7xr0hq.com1.z0.glb.clouddn.com/mvvm2.png)

这个图解准确地描述了什么是`MVVM`：一个`MVC`的增强版，我们正式连接了视图和控制器，并将表示逻辑从`Controller`移出放到一个新的对象里，即`ViewModel`。`MVVM`听起来很复杂，但它本质上就是一个精心优化的`MVC`架构，而`MVC`你早已熟悉。

- 模型(M):保存视图数据。

- 视图+控制器(V):展示内容 + 如何展示。

- 视图模型(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。

Android也有类似对于MVC架构的优化MVP，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。而且，Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，也就实现了重用。

具体请参见[MVC VS. MVP VS. MVVM](http://www.albertzuurbier.com/index.php/programming/84-mvc-vs-mvp-vs-mvvm)。

## MVVM实现登陆

### 需求：

1. 监听两个文本框的内容，有内容才允许按钮点击。
2. 默认登录请求。
3. 用MVVM实现，之前界面的所有业务逻辑。

### 分析：

1. MVC中，界面的所有业务逻辑都交给控制器做处理。
2. MVVM中，把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型。

### 步骤：

1. 创建LoginViewModel类，处理登录界面业务逻辑。
2. 这个类里面应该保存着账号的信息，创建一个账号Account模型。
3. LoginViewModel应该保存着账号信息Account模型。
4. 需要时刻监听Account模型中的账号和密码的改变，怎么监听？
5. 在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。
6. 每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号。
7. 这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号。
8. 监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑。
9. 执行命令，把数据包装成信号传递出去。
10. 监听命令中信号的数据传递。
11. 监听命令的执行时刻。


在controller中绑定视图模型

```objc
// 视图模型绑定
- (void)bindViewModel {
    // 给模型的属性绑定信号
    // 只要账号文本框一改变，就会给username赋值
    RAC(self.loginViewModel.user, username) = self.usernameTextField.rac_textSignal;
    RAC(self.loginViewModel.user, passwd) = self.passwdTextField.rac_textSignal;
    
    // 绑定登录按钮
    RAC(self.loginButton, enabled) = self.loginViewModel.enableLoginSignal;
    
    @weakify(self)
    // 监听登录按钮点击
    [[self.loginButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {
        @strongify(self)
        // 执行登录事件
        [[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];
        [self.loginViewModel.loginCommand execute:nil];
    }];
    
    [self.loginViewModel.loginCommand.executing subscribeNext:^(NSNumber *executing) {
        @strongify(self)
        if (executing.boolValue) {
            [MBProgressHUD showHUDAddedTo:self.view animated:YES].labelText = @"Loading...";
        } else {
            [MBProgressHUD hideHUDForView:self.view animated:YES];
        }
    }];
}
```

在LoginViewModel中初始化绑定

```objc
// 初始化绑定
- (void)initialBind {
    // 监听账号的属性值改变，把他们聚合成一个信号。
    self.enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.user, username),RACObserve(self.user, passwd)] reduce:^id(NSString *user,NSString *passwd){
        return @(user.length && passwd.length);
    }];
    
    // 处理登录业务逻辑
    self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
        
        NSLog(@"点击了登录");
        return [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {
            // 模仿网络延迟
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                [subscriber sendNext:@"登录成功"];
                // 数据传送完毕，必须调用完成，否则命令永远处于执行状态
                [subscriber sendCompleted];
            });
            return nil;
        }];
    }];
    
    // 监听登录产生的数据
    [self.loginCommand.executionSignals.switchToLatest subscribeNext:^(id x) {
        if ([x isEqualToString:@"登录成功"]) {
            NSLog(@"登录成功");
        }
    }];
}
```

## MVVM实现网络请求

### 需求

请求豆瓣图书信息，`https://api.douban.com/v2/book/search?q=iOS`。

### 分析
    
请求交给VM模型管理。

### 步骤
        
1. 控制器提供一个视图模型（`requesViewModel`），处理界面的业务逻辑。
2. VM提供一个命令，处理请求业务逻辑。
3. 在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。
4. 请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中。
5. 假设控制器想展示内容到`tableView`，直接让视图模型成为`tableView`的数据源，把所有的业务逻辑交给视图模型去做，这样控制器的代码就非常少了。



### 参考：

[Introduction to MVVM](https://www.objc.io/issues/13-architecture/mvvm/)

### 代码：
文章中的代码都可以从我的GitHub [`MVVMDemo`](https://github.com/lettleprince/MVVMDemo)找到。

