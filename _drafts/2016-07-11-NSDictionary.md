---
layout: post
title: "关于NSDictionary"
description: ""
category: articles
tags: [iOS]
comments: true
---

## 前言

聊得时候遇到这么个问题：实现上千对象的存储到字典（OC下就是NSDictionary）时，如果出现效率低下的问题，可能是什么原因？一脸懵逼啊，后来才知道重点在于NSDictionary的实现（hash算法及冲突的解决）。

## hash算法及冲突的解决

NSDictionary（字典）是使用 hash表来实现key和value之间的映射和存储的。hash基本思想是：首先在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 f ，使得 p=f(k) ，f 称为哈希函数 。创建哈希表时，把关键字为 k 的元素 直接存入地址为 f(k) 的单元 ；以后当查找关键字为 k 的元素时，再利用哈希函数计算出该元素的存储位置 p=f(k) ，从而达到按关键字直接存取元素的目的。当关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上 ，即  k1 ≠ k2  ，但  `H(k1) = H(k2)`，这种现象称为冲突，此时称 k1 和 k2 为同义词。实际中，冲突是不可避免的，只能通过改进哈希函数的性能来减少冲突。

综上所述，哈希法主要包括以下两方面的内容：
1.如何构造哈希函数
2.如何处理冲突。

### 哈希函数的构造方法

构造哈希函数的原则是：1.函数本身便于计算；2.计算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突。
下面介绍构造哈希函数常用的五种方法。
1．数字分析法
如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。例如，有80个记录，关键字为8位十进制整数d1d2d3…d7d8，如哈希表长取100，则哈希表的地址空间为：00~99。假设经过分析，各关键字中 d4和d7的取值分布较均匀，则哈希函数为：h(key)=h(d1d2d3…d7d8)=d4d7。例如，h(81346532)=43，h(81301367)=06。相反，假设经过分析，各关键字中 d1和d8的取值分布极不均匀， d1 都等于5，d8 都等于2，此时，如果哈希函数为：h(key)=h(d1d2d3…d7d8)=d1d8，则所有关键字的地址码都是52，显然不可取。
2．平方取中法
当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。
例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如图：

![hash-01](https://lettleprince.github.io/images/20160711-NSDictionary/hash-01.png)

3.分段叠加法
这种方法是按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有折叠法与移位法。移位法是将分割后的每部分低位对齐相加，折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加。例如：key=12360324711202065，哈希表长度为1000，则应把关键字分成3位一段，在此舍去最低的两位65，分别进行移位叠加和折叠叠加，求得哈希地址为105和907，如图：

![hash-02](https://lettleprince.github.io/images/20160711-NSDictionary/hash-02.png)

4.除留余数法
假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为 `h(k)= k%p` ，其中%为模p取余运算。
例如，已知待散列元素为（18，75，60，43，54，90，46），表长m=10，p=7，则有
    h(18)=18 % 7=4    h(75)=75 % 7=5    h(60)=60 % 7=4   
    h(43)=43 % 7=1    h(54)=54 % 7=5    h(90)=90 % 7=6   
    h(46)=46 % 7=4
此时冲突较多。为减少冲突，可取较大的m值和p值，如m=p=13，结果如下：
    h(18)=18 % 13=5    h(75)=75 % 13=10    h(60)=60 % 13=8    
    h(43)=43 % 13=4    h(54)=54 % 13=2     h(90)=90 % 13=12   
    h(46)=46 % 13=7
此时没有冲突，如图：

![hash-03](https://lettleprince.github.io/images/20160711-NSDictionary/hash-03.png)

解决方案主要有：

- 开放定址法。这种方法也称再散列法，其基本思想是：当关键字 key 的哈希地址 `p = H(key)` 出现冲突时，以 p 为基础(不是为key哦)，产生另一个哈希地址 p1 ，如果 p1 仍然冲突，再以 p1 为基础，产生另一个哈希地址 p2…，直到找出一个不冲突的哈希地址 pi，将相应元素存入其中。

- 再哈希法。这种方法是同时构造多个不同的哈希函数：`Hi = RH1(key) i=1 ， 2 ， … ， k`。当哈希地址 `Hi = RH1(key)` 发生冲突时，再计算 `Hi = RH2(key)`……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

- 链地址法。这种方法的基本思想是将所有哈希地址为 i 的元素构成一个称为同义词链的单链表 ，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

hash函数设计的好坏影响着数据的查找访问效率。数据在hash表中分布的越均匀，其访问效率越高。而在OC中，通常都是利用NSString 来作为键值，其内部使用的hash函数也是通过使用 NSString对象作为键值来保证数据的各个节点在hash表中均匀分布。


## 参考

[哈希表以及解决冲突的方法](http://blog.csdn.net/it_bloggers/article/details/21334123?utm_source=tuicool&utm_medium=referral)
[NSDictionary Class Reference](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSDictionary_Class/index.html#//apple_ref/doc/uid/TP40003648)

